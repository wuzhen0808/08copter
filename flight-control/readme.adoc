= The A8 Quad Copter Project Guide
:toc:
:toclevels: 3

//  1
== {counter:chapter}. Background

=== {chapter}.{counter:bg}. Introduction

The aim of this project is learning how to build a quad copter. Building a copter from nothing is a long task to go along with. It may take you month or more to learn the necessary concepts in background. So here this project are trying to get the study curve clear.

There are a lot of information around web about how to build a copter from scratch. Basically a copter is made up with a `frame`, `several motors`, a `micro controller board` , one or more peripherals as `sensors` and a `battery`. In order to implement the attitude control often an inertial measurement unit is necessary as the basic peripheral to provide the ability of sensing position, angular rate and magnet.

Beside the necessary parts above, there are still tools and small components around where to be prepared. Such staff will be listed at the appendix part.

We are paying efforts to make the code structurally clean and easy to read. We do not care much the performance at this moment. Please note the size of the MPU's flash and SRAM memories. You must make sure it's enough for the firmware to be located. Currently the size of the target firmware built here is around ?k.

Why we call this project A8? Primarily we need a short name. A word short enough when we type code in the namespace of C++. But we still can assign it some meaning. For example you can think it as a project that is built on top of Arduino. And it actually is started at the Autumn of 2003. It is August as well. There are a lot of words started with A. How about the 8? Then August is the 8th month. Additionally if you rotate the arduino board you will see the 8-like infinity sign printed on the board.
=== {chapter}.{counter:bg}. Concepts in background

==== {chapter}.{bg}.{counter:hard}. IMU sensors.

==== {chapter}.{bg}.{counter:hard}. PID controller

==== {chapter}.{bg}.{counter:hard}. Others

=== {chapter}.{counter:bg}. Quad copter hard ware
==== {chapter}.{bg}.{counter:hard}. Frame
The frame may not so much worth to introduce, it is not a abstract component to build a copter.Basically we need a four arms to install the motors and have a center platform to fix the PCB boards.

==== {chapter}.{bg}.{counter:hard}. Brush-less Motors

==== {chapter}.{bg}.{counter:hard}. ESC(electric speed controller)
A brush less motor need an ESC to drive itself. A quad copter need 4 brush less motors and 4 ESCs. We don't know how to work with plain brush-having motors. 


==== {chapter}.{bg}.{counter:hard}. Board

The board during the development of this project is Arduino-UNO-R4-MINIMA. The MPU is Cortex-M4 architecture and the model is RA4M1 from Renesas.

==== {chapter}.{bg}.{counter:hard}. IMU
Here we adopt MPU-9250 as the IMU(Inertial Measurement Unit) peripheral which contains three sensors which are accelerometer, gyro and magnetometer.

==== {chapter}.{bg}.{counter:hard}. RC
Remote control.

=== {chapter}.{counter:bg}. Software - Flight Control

==== {chapter}.{bg}.{counter:flight}. Attitude control
Attitude control is the most important part in a flight control system. A typical process flow is as below.

*** Attitude commands.
    An aileron command actually a instruction of rolling the vehicle to a desired attitude or called position(in certain coming time).The command value being clip to a value between -1 to 1. For a quad copter, aileron command can finally lead to a moving left or right.

*** Desired/reference angular velocity.
    After ths the command value on one axis is normalized(clip to the scope from -1 to 1), we then consider time variable and convert the abstract command to a proper speed. For instance if the attitude roll command value is -0.5, what time interval do we need the controller to accomplish this instruction? 
    
    Actually the -0.5 firstly is map to a radian and then divide it with a period in seconds. What we got it here by multiply -0.5 with a constant(for instance 0.75) and got the rps(-0.375). Which means rotating the vehicle around the X axis with a speed of 0.375 revolution per second at the direction of clock-wise. 
    
    The 0.75 is come from JSBSim's F450 aircraft configuration, i don't know how it got.

*** Error between the reference angular velocity and the actual ones.
    We compare the actual velocity(by sensor of gyro) with the desire velocity(from command). For example if the current angular velocity on X axis is 0, then the error on X axis is -0.375 (-0.375 - 0 = -0.375) rps. 

*** PID controllers - generate command to execute.
    After the error of velocity is determined, can we directly use it as the immediate instruction for the controller to execute? The answer is negative, we need a forward-seeable value. That is the job of PID controller.
    
*** Mixing the speed for each servo.
    We have the formulas to calculate the speed of the servo on different positions of the quad copter frame. Note that here we use NED(North-East-Down) frame in which the Z axis is downward and point to ground. And the positive rotation direction follows the law of right-hand.
[source,c++]
----
    float fr = heave - cmdRoll + cmdPitch + cmdYaw; // FR: Front right
    float al = heave + cmdRoll - cmdPitch + cmdYaw; // AL: After left
    float fl = heave + cmdRoll + cmdPitch - cmdYaw; // FL: Front left
    float ar = heave - cmdRoll - cmdPitch - cmdYaw; // AR: After right
----

    Rolling right command will decrease the speed of the right two propellers and increase the left two ones.
    Pitch back command will decrease the speed of the after two propellers and increase the front two ones.
    Yaw will decrease the two propellers with reverse rotation directions and increase the other two with same rotation direction.Here we assume the rotation direction of the front right and after-left propeller is clockwise in which a reaction force in the opposite direction will applied to the frame of the vehicle.

*** ESC controllers.
    According the output from above step, each ESC controller will update the servo with a speed required.

=== {chapter}.{counter:bg}. Software - RC

==== {chapter}.{bg}.{counter:rc}. TODO

== {counter:chapter}. Dependencies

=== {chapter}.{counter:dep}. Tools

==== {chapter}.{dep}.{counter:tools}. MSYS2[mandatory] 

MSYS2 provide a easier package manager pacman for us to manage the necessary dev tools.

==== {chapter}.{dep}.{counter:tools}. UCRT64[mandatory] 
Unified C Run Time for building the code for windows platform.
[source,shell]
----
$ pacman -S ... 
----

==== {chapter}.{dep}.{counter:tools}. PlatformIO[mandatory]
We rely on platformIO to build this project. File platformio.ini is the entry point to build code. Following command builds the firmware for the target environment.

How to install pio?

Run pio to build.
[source,shell]
----
$ pio run -e arduino_uno_minima
----

==== {chapter}.{dep}.{counter:tools}. gnuplot[optional]

This tool is optional and only needed in case you are going to plot data. 

How to install gnuplot?

[source,shell]
----
pacman -S ...
----

==== {chapter}.{dep}.{counter:libs}. JSBSim-Plot[optional]

This tool is optional and only needed in case you are going to plot data. 

This tool is for the purpose of automatically processing and calling gnuplot to plot data produced by JSBSim.

==== {chapter}.{dep}.{counter:libs}. Flight-Gear[optional]


==== {chapter}.{dep}.{counter:tools}. vscode[optional]

This tool is optional and only needed in case you need an IDE to modify the code.

How to install vscode?

How to update the IntelliSense settings according to the platformio.ini configuration file?
Following command will update the file `.vscode/c_cpp_properties.json` for the environment fc_native;

[source,shell]
----
$ pio.exe project init --ide vscode --environment fc_native
----

=== {chapter}.{counter:dep}. Libs

==== {chapter}.{dep}.{counter:libs}. FreeRTOS

==== {chapter}.{dep}.{counter:libs}. JSBSim-Kernel

==== {chapter}.{dep}.{counter:libs}. JSBSim-Plot

== {counter:chapter}. Architecture
TODO a box graph here.

=== {chapter}.{counter:folder}. lib/core

=== {chapter}.{counter:folder}. lib/FreeRTOS-Kernel
Do not edit the source code in this folder because all the code are from FreeRTOS official git repository.

This folder contains only the core code of FreeRTOS functions. We are using the thread/task and timer part of FreeRTOS.

You know the kernel part of FreeRTOS must be configured before it's application to concrete project. Actually you must provide a header file(FreeRTOSConfig.h) and set arguments by C language's preprocessing instructions. 

For example the below parameter is defined in the file of FreeRTOSConfig.h located in the lib/arduino/include folder.

[source,c++]
----
#define configNUM_THREAD_LOCAL_STORAGE_POINTERS (5)
----

=== {chapter}.{counter:folder}. lib/FreeRTOS-MemMang-heap4
Do not edit the source code in this folder because all the code are from FreeRTOS official git repository.

This folder contains one of the memory management policy which we adopted for both Arduino UNO and native environment. This is enabled by the settings of environment of uno_r4_minima in the platformIO configuration file 'platformio.ini'.

Why we don't use the Arduino_FreeRTOS.h which provided by the arduino-renesas framework itself? It's because we are trying to get the code structure clean, clear and then easy understandable. So we need the code independent with each part and as less as possible to depend 3rd party code or library.

=== {chapter}.{counter:folder}. lib/FreeRTOS-MSVC-MingW
Do not edit the source code in this folder because all the code are from FreeRTOS official git repository.

For the purpose of porting FreeRTOS to the native(MingW) environment.

=== {chapter}.{counter:folder}. lib/FreeRTOS-ArduinoRenesas-UNO
Do not edit the source code in this folder because all the code are from FreeRTOS official git repository.

For the purpose of porting FreeRTOS to the arduino_uno_minima environment.

=== {chapter}.{counter:folder}. hal
In order isolate the core code from the hardware environment we introduce this lib as the hardware abstract layer for defines of any environment related interfaces.

Please note the code below has defined a external global variable with type System. System is the interface to access the hardware part of the copters. 

[source,cpp]
----
//file:lib/hal/include/a8/hal/Hal.h
namespace a8::hal {
    extern System *S;
}
----

In each environment's application layer, you should provide the initialization code for this global variable. For example the code block showing below come from the src/arduino/main.cpp source code file.
[source,cpp]
----
#include "a8/hal/Hal.h"
System * a8::hal::S = new ArduinoSystem();
----

=== {chapter}.{counter:folder}. hal_arduino
This is the top most application layer by which all the layers underneath are mixed here for a final firmware under building. Actually it's not very accurate to say it the top most layer because we have put the main function in another folder/file. It is file `src/arduino/main.cpp`. 

Why we not providing a callback function? Like the way adopted by arduino framework in which the main function is replaced by two function `setup()` and `loop()`. May be arduino framework have a good reason for such design but here we believe in our context user should own the decision-making freedom. There are already a main wheel in hand we do not have a good reason to hide it and invent another one.

=== {chapter}.{counter:folder}. hal_native
As the function of folder arduino, native environment is defined here.

=== {chapter}.{counter:folder}. src
There folder contains the main entry function for each environment. How to distinguish them? The answer is by the building filter which is defined in the platformio.ini file.

For example the code below defines the filter when building firmware for arduino environment.

[source]
----
    build_src_filter = +<arduino/>
----
=== {chapter}.{counter:folder}. simulation
This folder contains the model file and command script that necessary to run flight gear as the 3D viewer.

All the files under the folder simulation/aircraft/arducopter are copied from the ArduCopter project.

//  3
== {counter:chapter}. Building

We have different environments configured through platformIO, they are fc_uno_r4_minima & fc_native etc.

Environment fc_uno_r4_minima is the target environment for the flight control system to be deployed on. 

The fc_native environment is designed here to support running the code in a simulation environment. In certain sense a simulator is actually more important here than a physical drone. 

At the moment the native environment only support MingW platform. 


Building for native environment:
[source,shell]
----
todo
----
Building for Arduino-UNO-Minima environment:
[source,shell]
----
todo
----

=== {chapter}.{counter:build}. Build program for native(MingW) environment
Change directory to the project home folder and run command below.

[source,shell]
----
$ pio run -e native
----

=== {chapter}.{counter:build}. Build for Arduino UNO R4 Minima board
Change directory to the project home folder and run command below.

[source,shell]
----
$ pio run -e uno_r4_minima
----

// // // // //
//  4
== {counter:chapter}. Tuning

=== {chapter}.{counter:tuning}. Tuning Simulation.

=== {chapter}.{tuning}.{counter:sim}. Build FC program.
[source,shell]
----
$ pio run -e fc_native
----

=== {chapter}.{tuning}.{counter:sim}. Start the program.

Program will listen and wait on a port for the connection from JSBSim script program.

[source,shell]
----
$ .pio/build/fc_native/program
----

=== {chapter}.{tuning}.{counter:sim}. Modify the airport location.
It's hard to see the screen of FG in case the local time of the simulation is in night mode. To avoid modifying the time manually from the GUI of FG. You can modify the longitude and latitude to your location.Open the JSBSim initialing file `simulation/aircraft/qc2309/rest.xml`.

[source,xml]
----
<?xml version="1.0"?>
<initialize name="Start up location">
    <latitude unit="DEG" type="geodetic"> 31.0 </latitude>
    <longitude unit="DEG"> 121.0 </longitude>
    ... ... 
</initialize>
----

=== {chapter}.{tuning}.{counter:sim}. Start Flight Gear.

Assuming the flight gear has been installed successfully.

The information in this section is referenced from the Ardu-Copter project.
See more detail please find the files under folder the sub folder Tools/autotest of ArduCopter project .
Change work directory to the folder `simulation` and run script `./fg.sh`.
You will see the view with a quad copter ready to listening on the port 5503.

[source,shell]
----
$ export FG_HOME=/path/to/flight/gear
$ cd simulation
$ ./fg.sh
----


=== {chapter}.{tuning}.{counter:sim}. Start the FC program in simulation env.

=== {chapter}.{counter:tune}. Tuning real world.
This part describe how to test the code with a real board. Please note there are dangerous if this is the first time to upload the firmware into a board with the motors connected. Do not install the propellers at the first evaluation and tuning the arguments step by step.

==== {chapter}.{tune}.{counter:real}. Connect all the components but not propellers.

*** Setup frame.
*** Fix the board with frame.
*** Install and setup the four motors.
*** Fix and connect the four ESCs with motors
*** Connect each ESC with the board. 
*** Fix and connect the IMU.
*** Fix and connect the battery.

==== {chapter}.{tune}.{counter:real}. Upload firmware

After you upload the firmware into the board.

== {counter:chapter}. Modify code 

=== {chapter}.{counter:modify}. About programming language
We prefer to use C++ in this project and avoid using C language in this project. You will see some code actually is C source code which ended with a '.c' suffix. They all come from 3rd party and we normally do not touch them unless necessary. Don't forget add the the `extern C{}` instruction if you have a c header to be included by a cpp source file.

=== {chapter}.{counter:test}. Running testing case

The test case currently only runnable with the native environment.

Example to run the test case test_cpp with in native environment.
[source, shell]
----
$ pio test -e native -f test_cpp
----

=== {chapter}.{counter:debug}. Debug arduino_uno_minima

<TODO>

=== {chapter}.{counter:debug}. Debug the native program

[source, shell]
----
$ gdb -ex run .pio/build/native/program.exe
----

The -g option is enabled for native env. 
[source]
----
build_flags = 		
	-std=gnu++11
	-lwinmm	
	-g
    ...
----

Following command is used to show the stack strace in case any exception encountered when running the program with gdb.

[source,shell]
----
(gdb) bt full
(gdb) bt full
#0  0x00007ff9f8acf61e in ucrtbase!abort () from C:\WINDOWS\System32\ucrtbase.dll
No symbol table info available.
... ...
#7  0x00007ff65e8eb5f6 in a8::core::Copter::setup (this=0x718c50) at lib\core\src\Copter.cpp:25
No locals.
#8  0x00007ff65e8e1f46 in a8::native::NativeCopter::setup (this=0x718c50)
    at lib\native\src\NativeCopter.cpp:14
No locals.
... ...
#10 0x00007ff65e8e2201 in main () at lib\native\src\main.c:194
----


== Appendix {counter:apx}. Building JSBSim static lib

You should get the lib file located here <some-path>/jsbsim/build/src/libJSBSim.a

[source,shell]
----
$ https://github.com/JSBSim-Team/jsbsim.git
$ 
$ mkdir jsbsim/build
$ cd jsbsim/build
$ cmake -G "MinGW Makefiles" ..
$ cd build
$ mingw-32-make 
----
More reference:
http://paul.chavent.free.fr/jsbsim.html

== Appendix {counter:apx}. Related Guidance

=== How to connect jsbsim with flight gear.

*** Setting output for jsbsm for aircraft c172x as below.

Edit file:<path-to-jsbsm>/airacraft/c172x/c172x.xml.
[source,xml]
----
<!---->
<output name="localhost" type="FLIGHTGEAR" port="5500" protocol="TCP" rate="30"/>
----

*** Open flight gear with fdm option to listening port on 5500.
[source,shell]
----
$ fgfs --fg-root=/path-to/flight.gear/data \
    --language=en \
    --fdm=external \
    --native-fdm=socket,in,30,localhost,5500,tcp \
    --airport=PHBK \
    --timeofday=noon 
----

*** Start jsbsim with scripts provide by official release.
[source,shell]
----
$ jsbsim --script=scripts/c172_elevation_test --realtime
----

*** You will see the plane in flight gear screen start moving.

== Appendix {counter:apx}. Related Hardware list

== Appendix {counter:apx}. Lib/tool list

=== FreeRTOS
https://www.freertos.org/RTOS.html

=== JSBSim
https://github.com/JSBSim-Team/jsbsim.git

https://discuss.ardupilot.org/t/simulate-arducopter-with-jsbsim/82235/12

https://jsbsim-team.github.io/jsbsim/

=== MSYS2

=== Cmake
In order to build JSBSim manually for the MingW env. The officially lib delivered is windows format JSBSim.lib which is not recognizable by the gcc compiler.

[source,shell]
----
$ pacman -S mingw-w64-ucrt-x86_64-cmake
----

=== Ghost-Script ??

mingw-w64-ucrt-x86_64-ghostscript
[source,shell]
----
$ pacman -S mingw-w64-ucrt-x86_64-ghostscript
----

== Appendix {counter:apx}. More References

=== AirSim
https://github.com/microsoft/AirSim

=== ArduPilot
*** Data Flow using JSBSim + FlightGear

https://ardupilot.org/dev/docs/sitl-with-jsbsim.html#sitl-with-jsbsim

=== FlightGear
https://www.flightgear.org/

https://ardupilot.org/dev/docs/flightgear-hardware-in-the-loop-simulation.html

https://wiki.flightgear.org/Menubar#How_to_Change_the_Default_Menubar_Font_Size

https://flightgear.sourceforge.net/manual/2020.3/en/getstart-en.html


=== Gym-JSBSim
Gym-JSBSim provides reinforcement learning environments for the control of fixed-wing aircraft using the JSBSim flight dynamics model. Gym-JSBSim requires a Unix-like OS and Python 3.6.
https://github.com/Gor-Ren/gym-jsbsim

=== Simulators provider list
https://ardupilot.org/dev/docs/simulation-2.html#simulation-2

=== About gcc and make
https://www3.ntu.edu.sg/home/ehchua/programming/cpp/gcc_make.html

