= The A8 Quad Copter Project Guide
:toc:
:toclevels: 3

//  1
== {counter:chapter}. Introduction

=== {chapter}.{counter:bg}. What is A8

The aim of this project is learning how to build a quad copter from zero. Learning is not building itself in that we focus on the structure of a general quad copter. Trying to provide a framework and guide a learner to build his or her concrete copter.

A8 stand for what? One reason is that Arduino UNO R4 is initially adopted here as the main board of the flight control system. Another reason is that this project started from Autumn and August of 2003. You know august is the 8th month of a year.

== {chapter}.{counter:bg}. Who may interestï¼Ÿ

If you are going learn the procedure to build a quad copter you may interested in. Building a copter from nothing is a long run. It may take you several month to get your idea into real. Here we are trying to get the concepts behind clearly visible to you.

=== {chapter}.{counter:bg}. Who NOT interest?

*** If you already know the detail about how to build a quad copter. Including the hardware components and software architecture of a copter or quad copter.

*** If you are seeking a ready-to-use flight control system.

== {chapter}.{counter:bg}. Tools involved.

There are a set of tools as well for you to develop and tuning your FCS.

== {chapter}.{counter:bg}. Principal.

One principal here is focusing on the readability of the source code but not the performance. Because the goal of this project is not a flyable copter but the procedure to build one.

== {counter:chapter}. Concepts framework
This section introduce the concepts involved. If you already know the background about how an copter is composed you can skip this section.

=== {chapter}.{counter:cf}. Hardware

Hardwares - a drone copter is composed with a `Frame`, several `Motors`, a `Micro Controller Board` , one or more `Sensors` , a `Battery`. 

==== {chapter}.{cf}.{counter:hard}. Frame
The frame may not so much worth to introduce, it is not a abstract component to build a copter.Basically we need a four arms to install the motors and have a center platform to fix the PCB boards.

==== {chapter}.{cf}.{counter:hard}. Brush-less Motors

==== {chapter}.{cf}.{counter:hard}. ESC(electric speed controller)
A brush less motor need an ESC to drive itself. A quad copter need 4 brush less motors and 4 ESCs. We don't know how to work with plain brush-having motors. 


==== {chapter}.{cf}.{counter:hard}. Board

The board during the development of this project is Arduino-UNO-R4-MINIMA. The MPU is Cortex-M4 architecture and the model is RA4M1 from Renesas.

==== {chapter}.{cf}.{counter:hard}. IMU

In order to achieve self balance, an `Inertial Measurement Unit` is adopted as the basic peripheral to provide the ability of knowing the actual attitude of the copter. 

For example MPU-9250 as one of the IMU(Inertial Measurement Unit) peripheral which contains an accelerometer,  a gyro and a magnetometer.

==== {chapter}.{cf}.{counter:hard}. RC
Remote control.

=== {chapter}.{counter:cf}. Software - Flight Control

Flight control is main software for a drone copter. And attitude control is the core of the flight control system. 

==== {chapter}.{cf}.{counter:flight}. PID controller
An general approach to deal with auto-control problem. 

*** P

*** I

*** D

==== {chapter}.{cf}.{counter:flight}. Attitude control
Attitude control is the most important part in a flight control system. A typical activity flow is as below.

*** Attitude commands.
    An aileron command actually a instruction of rolling the vehicle to a desired attitude or called position(in certain coming time).The command value being clip to a value between -1 to 1. For a quad copter, aileron command can finally lead to a moving left or right.

*** Desired/reference angular velocity.
    After ths the command value on one axis is normalized(clip to the scope from -1 to 1), we then consider time variable and convert the abstract command to a proper speed. For instance if the attitude roll command value is -0.5, what time interval do we need the controller to accomplish this instruction? 
    
    Actually the -0.5 firstly is map to a radian and then divide it with a period in seconds. What we got it here by multiply -0.5 with a constant(for instance 0.75) and got the rps(-0.375). Which means rotating the vehicle around the X axis with a speed of 0.375 revolution per second at the direction of clock-wise. 
    
    The 0.75 is come from JSBSim's F450 aircraft configuration, i don't know how it got.

*** Error between the reference angular velocity and the actual ones.
    We compare the actual velocity(by sensor of gyro) with the desire velocity(from command). For example if the current angular velocity on X axis is 0, then the error on X axis is -0.375 (-0.375 - 0 = -0.375) rps. 

*** PID controllers - generate command to execute.
    After the error of velocity is determined, can we directly use it as the immediate instruction for the controller to execute? The answer is negative, we need a forward-seeable value. That is the job of PID controller.
    
*** Mixing the speed for each servo.
    We have the formulas to calculate the speed of the servo on different positions of the quad copter frame. Note that here we use NED(North-East-Down) frame in which the Z axis is downward and point to ground. And the positive rotation direction follows the law of right-hand.
[source,c++]
----
    float fr = heave - cmdRoll + cmdPitch + cmdYaw; // FR: Front right
    float al = heave + cmdRoll - cmdPitch + cmdYaw; // AL: After left
    float fl = heave + cmdRoll + cmdPitch - cmdYaw; // FL: Front left
    float ar = heave - cmdRoll - cmdPitch - cmdYaw; // AR: After right
----

    Rolling right command will decrease the speed of the right two propellers and increase the left two ones.
    Pitch back command will decrease the speed of the after two propellers and increase the front two ones.
    Yaw will decrease the two propellers with reverse rotation directions and increase the other two with same rotation direction.Here we assume the rotation direction of the front right and after-left propeller is clockwise in which a reaction force in the opposite direction will applied to the frame of the vehicle.

*** ESC controllers.
    According the output from above step, each ESC controller will update the servo with a speed required.

=== {chapter}.{counter:cf}. Software - RC

==== {chapter}.{cf}.{counter:rc}. TODO

== {counter:chapter}. Dependencies
This section introduce the external tools and libs.

=== {chapter}.{counter:dep}. Tools

==== {chapter}.{dep}.{counter:tools}. MSYS2[mandatory] 

MSYS2 provide a easier package manager pacman for us to manage the necessary dev tools.

==== {chapter}.{dep}.{counter:tools}. UCRT64[mandatory] 
Unified C Run Time for building the code for windows platform.
[source,shell]
----
$ pacman -S ... 
----

==== {chapter}.{dep}.{counter:tools}. PlatformIO[mandatory]
We rely on platformIO to build this project. File platformio.ini is the entry point to build code. Following command builds the firmware for the target environment.

How to install pio?

Run pio to build.
[source,shell]
----
$ pio run -e arduino_uno_minima
----


==== {chapter}.{dep}.{counter:tools}. JSBSim[optional]
This tool is used to simulate and tuning the FCS under development.

==== {chapter}.{dep}.{counter:tools}. Flight gear[optional]
This tool is used to simulate and tuning the FCS under development.

==== {chapter}.{dep}.{counter:tools}. gnuplot[optional]

This tool is optional and is used to plot data and tuning FCS.

How to install gnuplot?

[source,shell]
----
pacman -S ...
----

==== {chapter}.{dep}.{counter:tools}. JSBSim-Plot[optional]

The code under folder lib/JSBSim-Plot is come from the git repository.

This tool automatically process and call gnuplot to plot data produced by JSBSim.

To build the executable file use following command.You may need copy and rename the executable file .pio/build/plot/program with any path you like.

[source,shell]
----
$ pio run -e plot
$ cp .pio/build/plot/program.exe /usr/local/bin/prep_plot
----

This tool is used to organize the command line options and the call the gnuplot command to plot CSV data.

Firstly it can list the title names and the indexes of each title in a CSV data file.
[source,shell]
----
$ prep_plot data_log/qc2309.csv
Known variable names in data file:
  1:  Time
  2:  q bar (psf)
  ... 
  30:  Altitude ASL (ft)
  31:  Altitude AGL (ft)
  32:  Phi (deg)
  33:  Theta (deg)
  34:  Psi (deg)
  ...
----

Secondly we need to create a xml file as the instruction for the prep_plot to work with.

[source,shell]
----
$ 
----

[source,shell]
----
$ cat simulation/plot.sh
#!/bin/tcsh
foreach file (*.csv)
  echo "process file:$file"
  if (-f data_plot/${file}.r.xml) prep_plot $file --plot=data_plot/${file}.r.xml | gnuplot
end
gs -q -dNOPAUSE -dBATCH -sDEVICE=pdfwrite -sOutputFile=output.pdf *.ps
----


==== {chapter}.{dep}.{counter:tools}. vscode[optional]

This tool is optional and only needed in case you need an IDE to modify the code.

How to install vscode?

How to update the IntelliSense settings according to the platformio.ini configuration file?
Following command will update the file `.vscode/c_cpp_properties.json` for the environment fc_native;

[source,shell]
----
$ pio.exe project init --ide vscode --environment fc_native
----

=== {chapter}.{counter:dep}. Libs

==== {chapter}.{dep}.{counter:libs}. FreeRTOS

==== {chapter}.{dep}.{counter:libs}. JSBSim-Kernel

==== {chapter}.{dep}.{counter:libs}. ncurses

== {counter:chapter}. Architecture

=== {chapter}.{counter:arch}. Diagram
A diagram to illustrate the dependence relation between parts of code.


=== {chapter}.{counter:arch}. Folder structure

==== {chapter}.{arch}.{counter:folder}. lib/util
Utility code which itself does not have any dependence.

It's the real kernel.

==== {chapter}.{arch}.{counter:folder}. lib/hal
Hardware abstract layer.

In order to minimize the external dependence this layer take the role of isolating the core code from the external env. 

Note the code below has defined a global variable with type System. System is the interface to access external env. 

[source,cpp]
----
//file:lib/hal/include/a8/hal/Hal.h
namespace a8::hal {
    extern System *S;
}
----

In each environment's application layer, you should provide the initialization the S variable. For example the code below is for arduino env.

[source,cpp]
----
#include "a8/hal/Hal.h"
System * a8::hal::S = new ArduinoSystem();
----

==== {chapter}.{arch}.{counter:folder}. lib/cil

Configuration interface layer.

Developer interface to select env and parameter settings.

Provide a plugin mechanism to get all the unknown env plugin-enabled by a package of code.

==== {chapter}.{arch}.{counter:folder}. lib/core

Implement all concept about a quad copter.

Have two external dependence, lib/util and lib/hal.

==== {chapter}.{counter:folder}. lib/hal_arduino

Env of the real world supported by arduino framework. Here we mix all external stuff such as Arduino UNO R4, IMU9250 and so on.

This part of code depends on lib/util.

Should not depend on lib/core, but currently not meet this rule. We should minimize such dependence and finally remove all such code into the src/arduino folder. Finally it should be serval lines of such code and all env related code should become some form of configuration.

==== {chapter}.{arch}.{counter:folder}. lib/hal_native
End of simulation with all necessary external stuff such as JSBSim, Flight Gear etc.

Depends on lib/util.

Should not depend on lib/core, but currently not meet this rule.


==== {chapter}.{arch}.{counter:folder}. lib/cil_x

==== {chapter}.{arch}.{counter:folder}. lib/FreeRTOS-Kernel
Do not edit the source code in this folder because all the code are from FreeRTOS official git repository.

This folder contains only the core code of FreeRTOS functions. We are using the thread/task and timer part of FreeRTOS.

You know the kernel part of FreeRTOS must be configured before it's application to concrete project. Actually you must provide a header file(FreeRTOSConfig.h) and set arguments by C language's preprocessing instructions. 

For example the below parameter is defined in the file of FreeRTOSConfig.h located in the lib/arduino/include folder.

[source,c++]
----
#define configNUM_THREAD_LOCAL_STORAGE_POINTERS (5)
----

==== {chapter}.{arch}.{counter:folder}. lib/FreeRTOS-MemMang-heap4
Do not edit the source code in this folder because all the code are from FreeRTOS official git repository.

This folder contains one of the memory management policy which we adopted for both Arduino UNO and native environment. This is enabled by the settings of environment of uno_r4_minima in the platformIO configuration file 'platformio.ini'.

Why we don't use the Arduino_FreeRTOS.h which provided by the arduino-renesas framework itself? It's because we are trying to get the code structure clean, clear and then easy understandable. So we need the code independent with each part and as less as possible to depend 3rd party code or library.

==== {chapter}.{arch}.{arch}.{counter:folder}. lib/FreeRTOS-MSVC-MingW
Do not edit the source code in this folder because all the code are from FreeRTOS official git repository.

For the purpose of porting FreeRTOS to the native(MingW) environment.

==== {chapter}.{arch}.{counter:folder}. lib/FreeRTOS-ArduinoRenesas-UNO
Do not edit the source code in this folder because all the code are from FreeRTOS official git repository.

For the purpose of porting FreeRTOS to the arduino_uno_minima environment.

==== {chapter}.{arch}.{counter:folder}. src
There folder contains the main entry function for each environment. How to distinguish them? The answer is by the building filter which is defined in the platformio.ini file.

For example the code below defines the filter when building firmware for arduino environment.

[source]
----
    build_src_filter = +<arduino/>
----
==== {chapter}.{arch}.{counter:folder}. simulation
This folder contains the model file and command script that necessary to run flight gear as the 3D viewer.

All the files under the folder simulation/aircraft/arducopter are copied from the ArduCopter project.

//  3
== {counter:chapter}. Building

We have mainly two env configured in platformio.ini, `fc_uno_r4_minima` & `fc_native`.

Env fc_uno_r4_minima is the target environment for the flight control system to be deployed on. 

Env fc_native is to support running the code in a simulation environment.

At the moment the native environment only support building with MingW under Windows. 

=== {chapter}.{counter:build}. Build FCS for native(MingW) environment
Change directory to the project home folder and run command below.

[source,shell]
----
$ pio run -e native
----

=== {chapter}.{counter:build}. Build FCS for Arduino UNO R4 Minima board
Change directory to the project home folder and run command below.

[source,shell]
----
$ pio run -e uno_r4_minima
----

=== {chapter}.{counter:build}. Build GS for native.

Install the ncurses libs.

Run build command.

[source,shell]
----
$ pio run -e gs_native
----



//  4

== {counter:chapter}. Tuning

=== {chapter}.{counter:tuning}. Tuning Simulation.

=== {chapter}.{tuning}.{counter:sim}. Build FC program.
[source,shell]
----
$ pio run -e fc_native
----

=== {chapter}.{tuning}.{counter:sim}. Start the program.

Program will listen and wait on a port for the connection from JSBSim script program.

[source,shell]
----
$ .pio/build/fc_native/program
----

=== {chapter}.{tuning}.{counter:sim}. Modify the airport location.
It's hard to see the screen of FG in case the local time of the simulation is in night mode. To avoid modifying the time manually from the GUI of FG. You can modify the longitude and latitude to your location.Open the JSBSim initialing file `simulation/aircraft/qc2309/rest.xml`.

[source,xml]
----
<?xml version="1.0"?>
<initialize name="Start up location">
    <latitude unit="DEG" type="geodetic"> 31.0 </latitude>
    <longitude unit="DEG"> 121.0 </longitude>
    ... ... 
</initialize>
----

=== {chapter}.{tuning}.{counter:sim}. Start Flight Gear.

Assuming the flight gear has been installed successfully.

The information in this section is referenced from the Ardu-Copter project.
See more detail please find the files under folder the sub folder Tools/autotest of ArduCopter project .
Change work directory to the folder `simulation` and run script `./fg.sh`.
You will see the view with a quad copter ready to listening on the port 5503.

[source,shell]
----
$ export FG_HOME=/path/to/flight/gear
$ cd simulation
$ ./fg.sh
----


=== {chapter}.{tuning}.{counter:sim}. Start the FC program in simulation env.

=== {chapter}.{counter:tune}. Tuning real world.
This part describe how to test the code with a real board. Please note there are dangerous if this is the first time to upload the firmware into a board with the motors connected. Do not install the propellers at the first evaluation and tuning the arguments step by step.

==== {chapter}.{tune}.{counter:real}. Connect all the components but not propellers.

*** Setup frame.
*** Fix the board with frame.
*** Install and setup the four motors.
*** Fix and connect the four ESCs with motors
*** Connect each ESC with the board. 
*** Fix and connect the IMU.
*** Fix and connect the battery.

==== {chapter}.{tune}.{counter:real}. Upload firmware

After you upload the firmware into the board.

== {counter:chapter}. Modify code 

=== {chapter}.{counter:modify}. About programming language
We prefer to use C++ in this project and avoid using C language in this project. You will see some code actually is C source code which ended with a '.c' suffix. They all come from 3rd party and we normally do not touch them unless necessary. Don't forget add the the `extern C{}` instruction if you have a c header to be included by a cpp source file.

=== {chapter}.{counter:test}. Running testing case

The test case currently only runnable with the native environment.

Example to run the test case test_cpp with in native environment.
[source, shell]
----
$ pio test -e native -f test_cpp
----

=== {chapter}.{counter:debug}. Debug arduino_uno_minima

<TODO>

=== {chapter}.{counter:debug}. Debug the native program

[source, shell]
----
$ gdb -ex run .pio/build/native/program.exe
----

The -g option is enabled for native env. 
[source]
----
build_flags = 		
	-std=gnu++11
	-lwinmm	
	-g
    ...
----

Following command is used to show the stack strace in case any exception encountered when running the program with gdb.

[source,shell]
----
(gdb) bt full
(gdb) bt full
#0  0x00007ff9f8acf61e in ucrtbase!abort () from C:\WINDOWS\System32\ucrtbase.dll
No symbol table info available.
... ...
#7  0x00007ff65e8eb5f6 in a8::fcs::Copter::setup (this=0x718c50) at lib\core\src\Copter.cpp:25
No locals.
#8  0x00007ff65e8e1f46 in a8::native::NativeCopter::setup (this=0x718c50)
    at lib\native\src\NativeCopter.cpp:14
No locals.
... ...
#10 0x00007ff65e8e2201 in main () at lib\native\src\main.c:194
----


== Appendix {counter:apx}. Building JSBSim static lib

You should get the lib file located here <some-path>/jsbsim/build/src/libJSBSim.a

[source,shell]
----
$ https://github.com/JSBSim-Team/jsbsim.git
$ 
$ mkdir jsbsim/build
$ cd jsbsim/build
$ cmake -G "MinGW Makefiles" ..
$ cd build
$ mingw-32-make 
----
More reference:
http://paul.chavent.free.fr/jsbsim.html

== Appendix {counter:apx}. Related Guidance

=== How to connect jsbsim with flight gear.

*** Setting output for jsbsm for aircraft c172x as below.

Edit file:<path-to-jsbsm>/airacraft/c172x/c172x.xml.
[source,xml]
----
<!---->
<output name="localhost" type="FLIGHTGEAR" port="5500" protocol="TCP" rate="30"/>
----

*** Open flight gear with fdm option to listening port on 5500.
[source,shell]
----
$ fgfs --fg-root=/path-to/flight.gear/data \
    --language=en \
    --fdm=external \
    --native-fdm=socket,in,30,localhost,5500,tcp \
    --airport=PHBK \
    --timeofday=noon 
----

*** Start jsbsim with scripts provide by official release.
[source,shell]
----
$ jsbsim --script=scripts/c172_elevation_test --realtime
----

*** You will see the plane in flight gear screen start moving.

== Appendix {counter:apx}. Related Hardware list

== Appendix {counter:apx}. Lib/tool list

=== FreeRTOS
https://www.freertos.org/RTOS.html

=== JSBSim
https://github.com/JSBSim-Team/jsbsim.git

https://discuss.ardupilot.org/t/simulate-arducopter-with-jsbsim/82235/12

https://jsbsim-team.github.io/jsbsim/

=== MSYS2

=== Cmake
In order to build JSBSim manually for the MingW env. The officially lib delivered is windows format JSBSim.lib which is not recognizable by the gcc compiler.

[source,shell]
----
$ pacman -S mingw-w64-ucrt-x86_64-cmake
----

=== Ghost-Script ??

mingw-w64-ucrt-x86_64-ghostscript
[source,shell]
----
$ pacman -S mingw-w64-ucrt-x86_64-ghostscript
----

== Appendix {counter:apx}. More References

=== AirSim
https://github.com/microsoft/AirSim

=== ArduPilot
*** Data Flow using JSBSim + FlightGear

https://ardupilot.org/dev/docs/sitl-with-jsbsim.html#sitl-with-jsbsim

=== FlightGear
https://www.flightgear.org/

https://ardupilot.org/dev/docs/flightgear-hardware-in-the-loop-simulation.html

https://wiki.flightgear.org/Menubar#How_to_Change_the_Default_Menubar_Font_Size

https://flightgear.sourceforge.net/manual/2020.3/en/getstart-en.html


=== Gym-JSBSim
Gym-JSBSim provides reinforcement learning environments for the control of fixed-wing aircraft using the JSBSim flight dynamics model. Gym-JSBSim requires a Unix-like OS and Python 3.6.
https://github.com/Gor-Ren/gym-jsbsim

=== Simulators provider list
https://ardupilot.org/dev/docs/simulation-2.html#simulation-2

=== About gcc and make
https://www3.ntu.edu.sg/home/ehchua/programming/cpp/gcc_make.html

